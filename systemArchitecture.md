# System Architecture — Outbound.im

## 1. Overview
Outbound.im is an AI-driven outbound communication platform that automates voice calls and multi-channel follow-ups. The architecture is modular so voice, messaging, analytics and integrations can scale independently.

**High level:** Outbound.im leverages modern, scalable web technologies to ensure performance, reliability, and flexibility.



---

## 2. Major Components
### Frontend
- **Stack:** React.js (Create React App or Vite)
- **Responsibilities:**
  - User authentication and role management
  - Campaign builder (Script Designer)
  - Lead management & CSV upload
  - Live dashboard and analytics
  - WebSocket client for real-time updates
- **Deployment:** Vercel or Netlify

### Backend
- **Stack:** Node.js + Express (or NestJS for structured code)
- **Responsibilities:**
  - REST API for frontend
  - Campaign orchestration and scheduling
  - Voice & messaging orchestration service
  - Webhook handlers for external APIs (Twilio, Payloads)
  - Authentication (JWT), RBAC, and auditing
- **Process model:** Separate logical services (monolith first, split to microservices later)

### Database & Storage
- **Primary DB:** PostgreSQL — relational data: users, campaigns, leads, call_logs, events
- **Secondary storage:** S3-compatible buckets for recordings, transcripts, and assets
- **Caching:** Redis for job queues, rate-limiting, and temporary state

### AI & Telephony Layer
- **Voice synthesis / recognition:** OpenAI Voice (or equivalent) + Twilio Programmable Voice
- **Voice flow runtime:** Service that converts campaign scripts into TTS calls and parses speech-to-text responses.
- **Decision engine:** Lightweight rule engine + NLP to tag outcomes (Interested / No / Follow-up)

### Messaging Layer
- **WhatsApp Cloud API** for message delivery
- **SendGrid / SMTP** for email follow-ups
- **Fallback SMS** via Twilio if WhatsApp unavailable

### Integrations
- **CRMs:** HubSpot, Salesforce (via their APIs)
- **Analytics / BI:** Export to BigQuery / Snowflake (future)
- **Monitoring:** Prometheus + Grafana or hosted alternatives (Datadog)

---

## 3. Component Communication & Flow
1. **User** triggers campaign from frontend → POST `/api/campaigns`
2. **Backend** validates leads, creates campaign record, and enqueues jobs into Redis queue
3. **Orchestrator Worker** consumes jobs and calls **TTS / Telephony API (Twilio)** using audio generated by the AI layer
4. **Telephony** executes call; Twilio sends webhook events (answered, completed)
5. **Worker** on webhook stores call_log, processes transcript (speech->text), runs NLP to tag outcome
6. **Backend** updates DB, emits WebSocket event to frontend, and pushes outcome to CRM via integration
7. Dashboard visualizes metrics in real-time

---

## 4. Data Model (high level)
- **users** (id, name, email, role, created_at)
- **campaigns** (id, name, owner_id, script, status, created_at)
- **leads** (id, campaign_id, name, phone, email, metadata)
- **call_logs** (id, lead_id, campaign_id, status, transcript, duration, audio_url)
- **events** (timestamped audit log entries)

---

## 5. Scalability & Feasibility
- **Start small (monolith + worker pool):** Node.js API + Redis worker queue to process calls concurrently.
- **Scaling plan:** Move voice engine, message service, and analytics to separate services (microservices) and add autoscaling groups.
- **Why feasible:** Twilio and OpenAI provide managed telephony and AI capabilities so core complexity is orchestration and state management — solvable with standard patterns (jobs, queues, idempotent webhooks).

---

## 6. Security & Compliance
- TLS everywhere (HTTPS)
- JWT-based authentication + short-lived refresh tokens
- Role-based access control (admin, user)
- Secure storage for API keys (secrets manager / environment vars)
- Data privacy: implement Do-Not-Call filtering, PII handling, and local data retention policies
- Audit logs for regulatory requirements

---

## 7. DevOps & CI/CD
- **Repo & branching:** GitHub, follow trunk-based or feature-branch workflow
- **CI:** GitHub Actions to run linting, tests, and build artifacts
- **CD:** Auto-deploy main to staging/production via Vercel (frontend) and Render / Heroku / AWS ECS (backend)
- **Observability:** Centralized logs (ELK), error tracking (Sentry), and metrics (Prometheus)

---

## 8. Example API Endpoints (sample)
- `POST /api/auth/login` → returns JWT
- `POST /api/campaigns` → create campaign
- `POST /api/campaigns/:id/start` → enqueue campaign
- `GET /api/campaigns/:id/metrics` → returns KPIs
- `POST /api/webhooks/twilio` → receives call events

---

## 9. Notes & Next steps
- Build MVP with core features: lead upload, simple TTS calls, call logging, and CRM sync.
- Add advanced features iteratively: Script Designer, sentiment analysis, multi-language voices.
- Create integration tests for webhooks and idempotency.

